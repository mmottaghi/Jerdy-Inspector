/***********************************************************************************
		Copyright (C) 2016 Mohammad D. Mottaghi

	Under the terms of the MIT license, permission is granted to anyone to use, copy, 
	modify, publish, redistribute, and/or sell copies of this source code for any 
	commercial and non-commercial purposes, subject to the following restrictions:
		
	1. The above copyright notice and this permission notice shall not be removed 
	from any source distribution.
	
	2. The origin of this file shall not be misrepresented; The name of the original 
	author shall be cited in any copy, or modified version of this source code.
	
	3. If used in a product, acknowledgment in the product documentation would be
	appreciated, but is not required.

	4. Modified versions must be plainly marked as such, and must not be 
	misrepresented as being the original source code.

	This source code is provided "as is", without warranty of any kind, express or 
	implied, including but not limited to the warranties of merchantability, fitness 
	for a particular purpose and noninfringement. In no event shall the author
	or copyright holders be liable for any claim, damages or other liability, 
	whether in an action of contract, tort or otherwise, arising from, out of or 
	in connection with this source code or the use or other dealings in it.

		Mohammd Mottaghi Dastjerdi (mamad[a~t]cs.duke.edu)
		Sep. 1,2016

***********************************************************************************/

#ifndef TestManagerH
#define TestManagerH

#include <StdCtrls.hpp>
#include<string>
#include<vector>
#include "JerdyParser.h"

using namespace std;
//---------------------------------------------------------------------------

typedef const char* TRoStr; // read-only string
template <int BUF_SIZE> class CStringChain
{
  private:
    char buf[BUF_SIZE];
    char *chain_end;

  public:
    CStringChain() {buf[0]=0; chain_end = buf;}
    const char* Start() const {return buf;}
    long  IsFull()   const  {return Capacity() <=0;}
    long  Capacity() const  {return BUF_SIZE - ((long)chain_end - (long)buf);}
    char* End()             {return chain_end;}
    char* NewString()
    {
      chain_end += strlen(chain_end)+1;
      *chain_end=0;
      return chain_end;
    }
};
//----------------------------------------------------------------------------
struct STestArgs
{
  CStringChain<5000>  buffer;
  vector<pair<TRoStr, TRoStr> >   non_arrays;
  vector<pair<TRoStr, vector<TRoStr> > > arrays;

  TRoStr          Get(TRoStr arg_name, TRoStr value_if_null=NULL);
  vector<TRoStr>* GetArray(TRoStr array_name);
  pair<TRoStr, TRoStr>* FindKeyValue(TRoStr key);
};
//---------------------------------------------------------------------------
class CTestManager
{
  private:
    CJerdyParser parser;
    CjStringRegistry* attrib_registry;
    char temp_buf[2000];

    struct SInMemHTML
    {
      char pid[20];
      char cid[20];
      char html[200];
      void CreateTagPair(TRoStr tag1, TRoStr tag2, TRoStr prefix1, TRoStr prefix2, TRoStr mid_tag=NULL)
      {
        long id1 = random(10000), id2 = random(10000);
        if (id1==id2)
          id2++;
        sprintf(pid, "%ld", id1);
        sprintf(cid, "%ld", id2);
        if (mid_tag)
          sprintf(html, "%s%s<%s id=%s><%s><%s id=%s>", prefix1, prefix2, tag1, pid, mid_tag, tag2, cid);
        else
          sprintf(html, "%s%s<%s id=%s><%s id=%s>", prefix1, prefix2, tag1, pid, tag2, cid);
      }
    };

    typedef bool (CTestManager::* TAssertFunction)(TRoStr , TRoStr , TRoStr , TRoStr , char , bool );
    bool ReadTestArguments(FILE *config_file, const char* test_start_word, STestArgs *args);
    void TestTagPairs(FILE *test_descr_file, STestArgs *args, TRoStr valid_outcomes, TAssertFunction Assert);
    bool ValidateNestability(TRoStr prefix_for_all, TRoStr parent_prefix, TRoStr parent, TRoStr child, char expected_outcome, bool report_failures_only);
    bool ValidateBlocking(TRoStr prefix_for_all, TRoStr parent_prefix, TRoStr parent, TRoStr child, char xo /*expected_outcome*/, bool report_failures_only);
    char FindNestingForPair(SInMemHTML *inmem, TRoStr parent, TRoStr child, TRoStr prefix1, TRoStr prefix2);

  public:
    TMemo *report;

    void        RunAutoGeneratedTest(TRoStr test_description_file_path);
    AnsiString  RunCustomTest(const char* test_config_file_path, const char* html_file, bool detailed_report);
    string      SerializeDOM(CjHtmlElement* subtree, long level, const char* main_buf_start, bool include_attributes);
};
#endif
